Kerberoes
=========

USAGE OF DES,RPC using Kerberoes model.(C language).

Contains folder RPC which tells how to use RPC on soloris.

Objective –
This project is designed to learn DES
(data encryption standard), client-server
programming using rpcgen, and authenticati
on protocols based on Kerberos design.
Problem –
For most applications, the client-application server communication should be
encrypted For sake of privacy. Therefore the client should first acquire
an encryption key and
somehow deliver it to the server before sending
application data to the server. The key is
generated by a key server. It is called session-key
since it is used for an entire session. In this
project, you will develop three components: a client program (C), a key-server (K), and an
application server (S). Each user (i.e., client C and the application service owner S) is assigned a
unique secret key, which is computed at the time of
creation of the accounts. This key is known to
the user (owner) and the key server K only. Obviously, this key can not be used for
communication between C and S, but it can be used
for delivering session keys to C and S. Given
below is the abstract of Kerberos approach.
1.
C sends a request to K to generate a sessi
on key for it to communicate with S. The
request contains just the id of C and S and it is
sent in plaintext as the id is known to all.
Let {C, S} denote this request.
2.
K tests if the two id are in its key database. If so, it generates a new session key, K
CS
,
prepares a reply, encrypts it using the secret ke
y of C, key(C), and sends it to C; let the
encrypted reply be denoted as {C, S, K
CS
, token}
C
. The
token
is an encrypted message,
which is encrypted using the secret key of S,
key(S). Let the encrypted token be denoted
as {C, S, K
CS
}
S.
K does not store K
CS
anywhere
.
3.
C decrypts the reply using its key(C) and extracts K
CS
and the token. It can not alter the
token, because it does not know key(S).
4.
Let m denote a message that C wants to send to S (m describes a service that C wants
from S). C first encrypts m using K
CS
to produce {m}
CS.
Next it prepares message M =
{C, {m}
CS,
token}; id of C is given in the plaintext, but the next two parts are encrypted.
C sends M to S.
5.
S reads M and obtains C, the id of the sender. It then decrypts the token using its own
key(S) and compares the id of C (stored in th
e token) with the plaintext id sent by the
sender. If the two id match, S is assured that C is a good guy.
6.
Next S extracts the session key, K
CS,
from the token and decrypts the second part of M to
obtain the service m requested by C. S processe
s the request, computes a reply r, encrypts
it using the session key, and sends {r}
CS
to C.
7.
C is expecting a reply from S. It uses K
CS
to decrypt it and obtains the reply r.
Above solution can be divided easily in two part
s – acquisition of the session key (steps 1-3), and
delivery of authenticated service (steps 4-7). Th
e above design has many limitations; for example,
it allows C and S to use the same session key for
subsequent communication for indefinite period.
Therefore, you should expand the protocols so that if the client continues to use the same key
after an assigned fixed period of time, S should
refuse the service. Expand your solution to realize
this requirement. Another limitation is that key
server may want that the session be used by C on
certain domain or hosts. For example, K might have a list of host or domain names. IF request for
a session key comes from a host not on this list, the service is denied. 
